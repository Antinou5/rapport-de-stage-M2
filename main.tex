\documentclass[11pt,a4paper]{article}

\setlength{\topmargin}{0cm}
\setlength{\headheight}{0.4cm}
\setlength{\headsep}{0.8cm}
\setlength{\footskip}{1cm}
\setlength{\textwidth}{17cm}
\setlength{\textheight}{25cm}
\setlength{\voffset}{-1.5cm}
\setlength{\hoffset}{-0.5cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\setlength{\parskip}{6pt}



\usepackage[latin1]{inputenc}
\usepackage[cyr]{aeguill}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb} %symboles math
\usepackage{amsfonts} %symboles math 
\usepackage{enumitem}
\usepackage{tikz} 
\usepackage{float}
\usepackage{braket}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{graphicx} 
\usepackage{fancyhdr} 
\usepackage{epstopdf} 
\usepackage[squaren,Gray]{SIunits}
\usepackage{tabularx} % gestion avancÃƒÂ©e des tableaux
\usepackage{url}
\usepackage{hyperref}
\usepackage{bbold}
\usepackage[format=hang]{caption}
\usepackage{subcaption}
\usepackage{stmaryrd} 
\usepackage{placeins} 

\usepackage{listings}
\usepackage{color}

%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}




\pagestyle{fancy}
\fancyhead[L]{\scriptsize \textsc{Une méthode de calibration non paramétrique pour les calorimètres de CMS}}
\fancyhead[R]{\scriptsize \textsc{Samuel Niang}} 
\fancyfoot[C]{ \thepage}

% commande de dÃƒÂ©placement d'un objet
\newcommand{\drawat}[3]{\makebox[0pt][l]{\raisebox{#2}{\hspace*{#1}#3}}}

\usepackage[printwatermark]{xwatermark}
\newwatermark[allpages,color=red!50,angle=45,scale=3,xpos=0,ypos=0]{DRAFT}


\begin{document}

% Pour faciliter la mise en forme de la page du titre, on supprime l'indentation automatique en dÃƒÂ©but de paragraphe
\setlength{\parindent}{0pt}

\thispagestyle{empty}

\includegraphics[height=2cm]{images/logoens.eps} \hfill \includegraphics[height=2cm]{images/logoucbl.eps} \hfill \includegraphics[height=2cm]{images/logounivlyon.eps}

\vspace{1cm}

\begin{tabularx}{\textwidth}{@{} l X l @{} }
{\sc Master Science de la matière} & & Rapport de stage\\
{\it \'{E}cole Normale Supérieure de Lyon} & & Samuel Niang\\
{\it Université Claude Bernard Lyon I} & & M2 Physique - Concepts et applications

\end{tabularx}


\begin{center}

\vspace{1cm}

\rule[11pt]{5cm}{0.5pt}

\textbf{\huge Une méthode de calibration non paramétrique pour les calorimètres de CMS.}

\rule{5cm}{0.5pt}

\vspace{2cm}

\parbox{15cm}{\small
\textbf{Résumé} : \\
\rm Dans le détecteur CMS, l'énergie des hadrons neutres est déterminée à partir de l'énergie mesurée dans les calorimètres électromagnétiques ($E_{\rm ecal}$) et hadroniques ($E_{\rm hcal}$). Une calibration est cependant nécessaire pour estimer l'énergie vraie du hadron neutre à partir de $E_{\rm ecal}$ et $E_{\rm hcal}$. Dans un premier temps, j'ai utilisé comme calibration une fonction linéaire de $E_{\rm ecal}$ et $E_{\rm hcal}$. Ensuite, afin de décrire la non linéarité de la mesure de l'énergie, j'ai inventé une nouvelle méthode de calibration non paramétrique.
}

\vspace{1cm}
\begin{center}
\includegraphics[height=2cm]{images/Logo_IPNL.jpg} 
\hspace{1cm}
\includegraphics[height=2cm]{images/Logo_CMS.png} 
\hspace{1cm}
\includegraphics[height=2cm]{images/cern_logo.png} 
\end{center}
\vspace{1cm}

\parbox{15cm}{
\textbf{Mots clefs} : \it Calibration, Modélisation, Physique des particules
} 

\vspace{0.5cm}

\parbox{15cm}{
Stage encadré par :

{\bf Colin Bernet}
\href{mailto:colin.bernet@cern.ch}{\tt colin.bernet@cern.ch} 

%Nom du Laboratoire d'accueil

{\it Bâtiment Paul Dirac\\
4, Rue Enrico Fermi\\
69622 Villeurbanne Cedex\\
Tél. : +33 (0) 4 72 44 84 57}

} %fin de la commande \parbox encadrant / laboratoire d'accueil

\vspace{0.5cm}

\end{center}
\vfill
\hfill \today

\newpage
\thispagestyle{empty}
\tableofcontents
\setcounter{page}{1}

\setlength{\parindent}{16pt}





\newpage
\section{Introduction}
Après avoir permis la découverte expérimentale du boson de Higgs en 2012, les expériences généralistes ATLAS \cite{HiggsATLAS} et CMS \cite{HiggsCMS} installées sur le LHC du CERN, sont toujours en place dans l'optique de découvrir de la nouvelle physique au-delà du modèle standard.

Les détecteurs ATLAS et CMS sont basés sur les mêmes principes : cylindriques, ils sont constitués d'un ensemble de sous-détecteurs disposés en couches concentriques autour du point d'interaction. Les informations provenant de ces sous-détecteurs sont combinées pour déterminer le type, l'énergie et la direction des particules de l'état final de la collision, pour pouvoir mesurer les propriétés de celle-ci, et par exemple determiner si une particule instable encore inconnue a été produite. 

Nous allons nous intéresser plus spécifiquement au détecteur CMS \cite{CMS}. Celui-ci dispose  :
\begin{itemize}
\item d'un champ magnétique, pour courber la trajectoire des particules chargées;
\item d'un trajectographe, pour reconstruire la trajectoire des particules chargées, et ainsi obtenir la charge et l'impulsion;
\item d'un calorimètre électromagnétique (ECAL) \cite{ECAL}, constitué d'un cristal de tungstate de plomb, permettant de collecter les dépôts d'énergie des particules, principalement électrons et photons, mais aussi hadrons chargés et neutres);
\item d'un calorimètre hadronique (HCAL) \cite{HCAL}, composé de plusieurs couches d'absorbeur en laiton et de carreaux scintillateurs en plastique, avec une segmentation grossière. La resolution du HCAL pour la mesure de l'energie $E$ d'un hadron est de l'ordre de $100\%\sqrt{(E / \SIUnits{}{\giga\electronvolt})}$;
\item de chambres à muons, qui permettent l'dentification de ces particules, les seules à pouvoir y parvenir.
\end{itemize}

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.7\textwidth]{images/detecteur.pdf}
\caption{Une esquisse des interactions spécifiques des particules dans une tranche transversale du détecteur CMS.}
\label{schemaCMS}
\label{detecteur}
\end{center}
\end{figure}

Détaillons alors le comportement des particules  :
\begin{itemize}
    \item photons (exemple 1 dans la Fig. \ref{schemaCMS}) :
    	\begin{itemize}
		\item déposent leur énergie dans ECAL;
	\end{itemize}
    \item $e^+,e^-$ (exemple 2 dans la Fig. \ref{schemaCMS}) :
        \begin{itemize}
        		\item produisent une trace dans le trajectographe;
		\item déposent leur énergie dans ECAL;
        \end{itemize}
    \item hadrons chargés (exemple 3 dans la Fig. \ref{schemaCMS}) :
        \begin{itemize}
        		\item produisent une trace dans le trajectographe;
    		\item déposent en minorité des cas leur énergie dans ECAL;
    		\item déposent leur énergie dans HCAL;
		\item fin de course dans HCAL;
        \end{itemize}
    \item hadrons neutres (exemple 4 dans la Fig. \ref{schemaCMS}) :
        \begin{itemize}
        		\item déposent leur énergie dans le HCAL;
		\item déposent en minorité des cas leur énergie dans ECAL;
		\item fin de course dans HCAL;
        \end{itemize}
    \item $\mu^+,\mu^-$ (exemple 5 dans la Fig. \ref{schemaCMS}) :
        \begin{itemize}
        		\item produisent une trace dans le trajectographe;
		\item traversent ECAL, HCAL;
		\item chambre à muons.
        \end{itemize}
\end{itemize}
\`A noter que dans notre étude seuls les hadrons neutres nous intéressent. \\

Le connaissance des dépôts d'énergies et du comportement des particules dans les différentes parties du détecteur nous permette de reconnaître et distinguer les particules, cette opération s'appelle le \textit{Particle Flow (PF)}. Cependant, il est aussi nécessaire n'estimer l'énergie des particules ($E_{\rm true})$ à l'aide d'une calibration des calorimètres. En effet, ces derniers ne présentent pas une réponse linéaire et la somme des énergies dans les calorimètres ne correspond pas à l'énergie de la particule. Cette énergie de calibration sera notée $E_{\rm calib}$.

En première approximation, nous déterminerons l'énergie calibrée par une fonction linéaire de l'énergie lue dans le ECAL (énergie notée par la suite $E_{\rm ecal}$) et de celle lue dans le HCAL (notée par la suite $H_{\rm ecal}$). Cette méthode sera présentée dans la section \ref{LR}.

Ensuite, ce rapport présente de nouvelles techniques de calibration qui permettent de prendre en compte la non-linearité des calorimètres. Ces techniques seront présentées dans les sections \ref{CL} et \ref{KNN}.\\
Enfin, dans la section \ref{comparaison} nous comparerons ces méthodes. 

\section{Production de l'échantillon}
- paragraphe de Colin sur la simulation\\
-  passer de Root à pyhton -> 1 ligne pour dire que j'ai fait un script\\
-> plot du nage de point\\
\begin{figure}[!h]
\begin{center}
\includegraphics[height=5cm]{images/pictures/testLinearRegression/LinearRegression_plot3D_training.png}
\caption{Le nuage de points modélisé}
\end{center}
\end{figure}
- séparation ecal != 0 , ecal = 0 : \\

On séparera et traitera différemment les événements qui ont $E_{\rm ecal} = 0$.  Ces événements sont liés à des particules qui ont interagit avec le détecteur hardronique mais pas avec le détecteur électromagnétique (cf Fig.\ref{detecteur}). Cette séparation se justifie par le fait que modéliser les dépôts d'énergie dans les deux calorimètres pour en conclure ce qui se passe dans le cas particulier où il n'y a des dépôts que dans un amène un biais. Ainsi, à chaque "création" de calibration, on créera en fait deux modèles.\\
-> image illustrant la séparation : ecal + hcal < 150
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/explain/limit.png}
%\caption{On place une limite à $E_{\rm ecal}+E_{\rm hcal} = 150$. \'A gauche, ..., en haut à droite, ..., en bas à doite, ...}
%\end{center}
%\end{figure}

\section{Calibration par régression linéaire}
\label{LR}

- Un première calibration, non binnée\\
\begin{equation}
    E_{\rm true} = a_1 E_{\rm ecal} + a_2 E_{\rm hcal} + b
\end{equation}
- trouver la meilleure $a_1, a_2, b$\\
- pas d'incertitude\\
- méthode des moindres carrés, ref scikitLearn \cite{scikitLR}\\
- on limite les points de la calibration, lim min, lim max\\

- lancer la calibration, doc GitHub \cite{GitHubLR}\\
paramères : $lim = 150, lim_{min} = 20, lim_{max} = 80$\\
régession obtenue : \\
for ecal == 0 : \\
        ecalib = 0.960326144365 hcal + 5.92100531606\\
for ecal != 0 : \\
        ecalib = 1.34578479311 ecal + 0.987111240421 hcal + 8.27380815395\\
-> plot surface, courbe de calibration\\
- on calibre un second jeu de données\\
-> plot ecalib/etrue\\
- que vaut la calibration?\\
-> mise en évidence des non linéarités\\
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height=5cm]{images/pictures/testLinearRegression/LinearRegression_plot3D_surf.eps}
%\caption{Le nuage de points modélisé (à gauche) par un plan (à droite).}
%\end{center}
%\end{figure}
%
%Nous avons ainsi modélisé le nuage de point par un plan, pour voir si cela était réaliste, nous allons d'abord regarder ce qui se passe dans le plan $E_{\rm ecal} = 0$ :
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height =5cm]{images/pictures/testLinearRegression/LinearRegression_calibration.png}
%\caption{Courbe de calibration pour $E_{\rm ecal} = 0$.}
%\end{center}
%\end{figure}
%
%Nous constatons alors que la courbe ne passe pas par le le coeur du nuage de point à faible énergie. Pour avoir une vue d'ensemble, nous allons tracer  $E_{\rm calib}/E_{\rm true}$ qui doit être proche de $1$ si la calibration est bonne. \\
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height =4.5cm]{images/pictures/testLinearRegression/LinearRegression_ecalib_over_etrue_functionof_ecal_hcal.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm ecal}$ et $E_{\rm hcal}$.}
%\end{center}
%\end{figure}
%
%En regardant la figure de droite, nous constatons que comme prévu la régression linéaire est mauvaise à faible énergie car en moyenne, $E_{\rm calib}/E_{\rm true}$ n'est pas proche de $1$. Plus intéressant, la figure de droite met en avant les non-linéarités du nuage de point.\\
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height =4.5cm]{images/pictures/testLinearRegression/LinearRegression_ecalib_over_etrue.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$.}
%\label{ecaliboveretrueLR}
%\end{center}
%\end{figure}
%
%Ici nous constatons que à faible et haut $E_{\rm true}$, la calibration ne donne pas de bons résultats. En effet, la courbe de la moyenne (fit gaussien) s'écarte très fortement d'une constante égale à 1.
- origine de la courbe de fit\\
- comment fait-on un fit\\
-scipy \cite{scipyFit}\\
%	A différents moment, nous aurons besoin de calculer des moyennes. Or souvent, la moyenne classique ne serait pas représentative de ce que tous souhaitons montrer car certains points sont ont des valeurs $E_{\rm ecal},E_{\rm hcal}$ mal estimées car la simulation prend en compte les défauts des calorimètres. Il serait donc alors incorrecte de les prendre en compte pour juger l'efficacité d'une calibration car ils sont complètement incohérents.\\
%Pour résoudre ce problème, nous allons ajuster une gaussienne de la distribution des points à moyenner et choisir considérer que la moyenne à prendre en compte est la moyenne de la gaussienne. Ainsi, les points aberrants totalement écarté du centre de la distribution ne perturberont pas le calcul de la moyenne alors que dans le cas d'une moyenne classique, ils peuvent fortement attirer la moyenne vers eux.\\
%Ces points aberrants peuvent également venir d'une particule qui se serait décomposée avant le calorimètre. Ainsi on trouve près de l'origine, des points à fort $E_{\rm true}$ et pour de faibles valeurs de  $E_{\rm ecal}$ et $E_{\rm hcal}$, et ces points ne sont pas du tout représentatif de l'efficacité d'une calibration. 
%
%\begin{minipage}{0.5\linewidth}
%	\begin{center}
%	\includegraphics[height=5cm]{images/pictures/testKNNGF/KNNGaussianFit_example_hist.eps}
%	\end{center}
%\end{minipage}
%\hfill
%\begin{minipage}{0.45\linewidth}
%	Ici, on peut voir sur cet exemple que si nous prenons la moyenne classique de $E_{\rm true}$,  on obtient $79.12$, or la moyenne de la gaussienne fitée est de $77.82$, au vu de ce que nous avons dit précédemment, nous considèrerons que la seconde est plus judicieuse.
%\end{minipage}
%
%\subsection{Comment est fait un fit ?}
expliquer : \\
- barre d'erreur\\
- minimisation du chi2\\
- un bon chi2 réduit ?\\
- quand nous ferons un fit gaussien ce sera toujours le même principe\\

%\newpage
\section{Méthode non paramétrique binnée}
\label{CL}
- principe de l'algo\\
- méthode binné\\
- illustration : \\
\begin{figure}[!h]
\begin{center}
\includegraphics[height=4cm]{images/pictures/testCalibrationLego/CalibrationLego_plot3D_legos.eps}
\caption{Le nuage de points modélisé par des legos}
\end{center}
\end{figure}

%Comme nous l'avons vu précédemment, il faut une calibration qui prenne en compte les non-linéarité. Ici, l'idée est de découper le plan $(E_{\rm ecal},E_{\rm hcal})$ en carré et de calculer la moyenne des $E_{\rm true}$ dans chaque carré qui sera la valeur $E_{\rm calib}$.\\
%Ainsi pour prédire une énergie de $E_{\rm calib}^i$ pour un point $(E_{\rm ecal}^i,E_{\rm hcal}^i)$, nous allons regarder dans quel carré il se trouve et retourner la valeur d'énergie calibrée correspondante, faisant apparaître ainsi des "legos".
%
->{Résultat de la calibration}
- lancer la calibration ref Git \cite{GitHubCL}\\
- paramètres \\
-> plot surface, courbe de calibration\\
- on calibre un second jeu de données\\
-> plot ecalib/etrue\\
- biais lié aux bins \\
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height=4cm]{images/pictures/testCalibrationLego/CalibrationLego_plot3D_legos.eps}
%\includegraphics[height=4cm]{images/pictures/testCalibrationLego/CalibrationLego_plot3D_surf.eps}
%\caption{Le nuage de points modélisé par des legos (à gauche) ainsi que la surface correspondante (à droite). $100\times100$ legos.}
%\end{center}
%\end{figure}
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testCalibrationLego/CalibrationLego_calibration.png}
%\caption{Courbe de calibration pour $E_{\rm ecal} = 0$.}
%\end{center}
%\end{figure}
%
%Bien que cette méthode prenne en compte les linéarité, nous pouvons voir sur les figures ci-dessus qu'il y a un effet de pas, ce qui n'est pas bon car beaucoup trop d'événements on le même $E_{\rm calib}$ et la courbe de calibration ne suit pas bien le coeur de distribution, surtout à faible énergie.
%
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testCalibrationLego/CalibrationLego_ecalib_over_etrue.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$.}
%\label{ecaliboveretrueCL}
%\end{center}
%\end{figure}
%
%Cet effet de pas se retrouve également si l'on trace $E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$ (Fig. \ref{ecaliboveretrueCL}) et nous y voyons alors un structure (des hyperboles) liées aux points qui ont la même énergie de calibration (contrairement à la régression linéaire Fig.  \ref{ecaliboveretrueLR}).\\
%Cet illustration montre à nouveau que nous sommes loin d'une répartition des points autour de $E_{\rm calib}/E_{\rm true} = 1$.
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testCalibrationLego/CalibrationLego_ecalib_over_etrue_functionof_ecal_hcal.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm ecal}$ et $E_{\rm hcal}$.}
%\end{center}
%\end{figure}
%
%Ici nous constatons malgré tout que nous avons mieux pris en compte la non-linéarité, mais que en majorité, l'énergie calibrée est sur-estimée.
%
%
%
%
\section{Méthodes basées sur les plus proches voisins}
\label{KNN}
\subsection{Moyenne pondérée}
-{Principe général de l'algorithme}\\
- trouver les plus proches voisin :  sckitlearn \cite{scikitKNN}, algorithmes de recherches optimisés\\

\begin{figure}[!h]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGF/KNNGaussianFit_neighborhood.png}
		\caption{$n_{voisins} = 2000$ pour $E_{\rm ecal} = 0$, $n_{voisins} = 250$ pour $E_{\rm ecal} \neq 0$}
		\label{neighbors}
		\end{center}
\end{figure}

- moyenne pondérée par une gaussienne\\
- pas assez lissé, des particules à fort Etrue mal détectées perturbent la calibration, il faut les enlever
%Nous utilisons encore des données simulées pour effectuer une calibration, chaque particule simulée $i$ est vue comme un point d'un espace tridimensionnel possédant des coordonnées $(E_{\rm ecal}^i, E_{\rm hcal}^i,E_{\rm true}^i)$, correspondant respectivement à l'énergie déposée dans le calorimètre électromagnétique, dans le calorimètre hadronique et l'énergie vraie.\\
%Pour trouver l'énergie calibrée d'un point de coordonnées $(E_{\rm ecal}^0, E_{\rm hcal}^0)$ :
%\begin{itemize}
%	\item on recherche ses $k$ plus proches voisins dans le plan $(E_{\rm ecal}, E_{\rm hcal}) \rightarrow (E_{\rm ecal}^i, E_{\rm hcal}^i), i \in [|1,...,k|]$
%	\begin{figure}[!h]
%	\begin{center}
%		\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGF/KNNGaussianFit_neighborhood.png}
%		\caption{$n_{voisins} = 2000$ pour $E_{\rm ecal} = 0$, $n_{voisins} = 250$ pour $E_{\rm ecal} \neq 0$}
%		\label{neighbors}
%		\end{center}
%	\end{figure}
%	\item on effectue une moyenne pondérée une moyenne pondérée de l'énergie vraie de ces plus proches voisins $\rightarrow E_{\rm calib}^0$ : l'énergie calibrée 
%\end{itemize}
%
%La moyenne pondérée va donc s'exprimer ainsi :
%\begin{equation}
%	 E_{\rm calib}^0 = \frac{\sum_{i=1}^k g(E_{\rm ecal}^i, E_{\rm hcal}^i) \times E_{\rm true}^i}{\sum_{i=1}^k g(E_{\rm ecal}^i, E_{\rm hcal}^i)}
%\end{equation}
%Dans notre cas nous avons pris pour $g$ la distribution gaussienne $g(\vec{x}) = \exp{-\frac{1}{2}(\frac{(\vec{x} - \vec{x}^0)^2}{\sigma^2})}$, pour donner plus d'importance aux plus proches des k plus proches voisins.\\
%
-{Résultat de la calibration}\\
-  créer la calibration, doc git \cite{GitHubKNN}
- paramètres : \\
$lim =150, n_{\rm neighbors, Ecal = 0} = 2000, n_{\rm neighbors, Ecal \neq 0} = 250, lim = 150, \sigma  = 5$\\
weights = 'gaussian'\\
-> plot surface, courbe de calibration\\
- on calibre un second jeu de données\\
-> plot ecalib/etrue\\
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.37\textwidth]{images/pictures/testKNN/KNN_plot3D_training.png}
%\includegraphics[width=0.37\textwidth]{images/pictures/testKNN/KNN_plot3D_surf.eps}
%\caption{Le nuage de points modélisé (à gauche) par une surface (à droite).}
%\end{center}
%\end{figure}
%
%Nous constatons  ici que la surface est beaucoup plus lisse que pour la méthode précédente, mais en regardant le cas particulier de $E_{\rm ecal} = 0$, nous constatons encore une fois que à faible énergie, la courbe de calibration ne passe pas par le coeur de la distribution. Cela vient du fait qu'il y a des points aberrants qui ont une forte énergie vraie mais qui ont une très faible énergie détectée par les calorimètres. \\
%Il nous faut donc un moyen pour ne plus les prendre en compte pour avoir une courbe de calibration plus réaliste. \\
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNN/KNN_calibration.png}
%\caption{Courbe de calibration pour $E_{\rm ecal} = 0$.}
%\end{center}
%\end{figure}
%
%Malgré tout, en regardant la Fig.  \ref{ecaliboveretrueKNN}, nous constatons que les points sont mieux répartis autour de $E_{\rm calib}/E_{\rm true} = 1$.
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNN/KNN_ecalib_over_etrue.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$.}
%\label{ecaliboveretrueKNN}
%\end{center}
%\end{figure}
%
%Nous prenons également en compte les non-linéarité dans ce cas mais nous sur-estimons encore la valuer de l'énergie calibrée (encore une fois, à cause de ces points à fort $E_{\rm true}$
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNN/KNN_ecalib_over_etrue_functionof_ecal_hcal.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm ecal}$ et $E_{\rm hcal}$.}
%\end{center}
%\end{figure}
%
%
%
\subsection{Nettoyage gaussien}
\subsubsection{Principe général de l'algorithme}
- on enlève les points éloignés du coeur de la distribution\\
- principe de l'algo\\
- interpolation \cite{scipyInterp}\\
%Cette méthode est assez similaires à la précédente. Elle se base sur la constatation que la distribution en énergie vraie des paquets de plus proches voisins est un distribution gaussienne. Nous allons donc en utilisant la méthode des moindres carrés trouver les paramètres de la gaussienne en question et ne prendre en compte les plus proches voisins dont l'énergie vraie est $\mu -c\sigma \leq E_{\rm true}^i \leq \mu + c\sigma$ (nous prenons par défaut $c = 2$), avec $\mu, \sigma$ la moyenne et l'écart type de la distribution gaussienne.\\
%Principe de l'algorithme :
%\begin{itemize}
%	\item on considère des points $(E_{\rm ecal}^{0,j}, E_{\rm hcal}^{0,j})$ où nous allons évaluer l'énergie calibrée.
%	\item pour chaque $(E_{\rm ecal}^{0,j}, E_{\rm hcal}^{0,j})$ :
%	\begin{itemize}
%		\item on recherche ses $k$ plus proches voisins dans le plan $(E_{\rm ecal}, E_{\rm hcal}) \rightarrow (E_{\rm ecal}^i, E_{\rm hcal}^i), i \in [|1,...,k|]$
%		\item on trouve la gaussienne correspondante $\mu -c\sigma \leq E_{\rm true}^i \leq \mu + c\sigma$
%		\item on ne conserve que les voisins dont : $\mu -c\sigma \leq E_{\rm true}^i \leq \mu + c\sigma$
%		\item on effectue une moyenne pondérée une moyenne pondérée de l'énergie vraie de ces plus proches voisins $\rightarrow E_{\rm calib}^0$ : l'énergie calibrée 
%	\end{itemize}
%	\item on effectue une interpolation pour donner une valeur d'énergie calibrée quelque soit $(E_{\rm ecal}^{0}, E_{\rm hcal}^{0})$
%\end{itemize}
%
%\subsection{Efficacité du fit}
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGC/KNNGaussianCleaning_chi2_calib.eps}
%\caption{Le $\chi^2$ réduit pour chaque fit effectué.}
%\end{center}
%\end{figure}
%
\subsubsection{Résultat de la calibration}
- doc git \cite{GitHubKNNGC}
- paramètres : \\
$lim =150, n_{\rm neighbors, Ecal = 0} = 2000, n_{\rm neighbors, Ecal \neq 0} = 250, lim = 150, \sigma  = 5$\\
weights = 'gaussian'\\
algorithm = 'auto'\\
energystep = 1\\
kind = 'cubic'\\
cut = 2\\
-> plot surface, courbe de calibration\\
- on calibre un second jeu de données\\
-> plot ecalib/etrue\\
- mise en évidence des non linéarités\\
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.37\textwidth]{images/pictures/testKNNGC/KNNGaussianCleaning_plot3D_training.png}
%\includegraphics[width=0.37\textwidth]{images/pictures/testKNNGC/KNNGaussianCleaning_plot3D_surf.eps}
%\caption{Le nuage de points modélisé (à gauche) par une surface (à droite).}
%\end{center}
%\end{figure}
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGC/KNNGaussianCleaning_calibration.png}
%\caption{Courbe de calibration pour $E_{\rm ecal} = 0$.}
%\end{center}
%\end{figure}
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGC/KNNGaussianCleaning_ecalib_over_etrue_functionof_ecal_hcal.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm ecal}$ et $E_{\rm hcal}$.}
%\end{center}
%\end{figure}
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGC/KNNGaussianCleaning_ecalib_over_etrue.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$.}
%\end{center}
%\end{figure}
%
%
%
%
%\newpage
\subsection{Fit gaussien}
\subsubsection{Principe général de l'algorithme}
- principe de l'algo\\
- Ecalib = $\mu$\\
%Ici, il s'agit du même principe que précédemment mais nous allons considérer que la valeur de $E_{\rm calib}$ est la moyenne de la gaussienne. 
%Principe de l'algorithme :
%\begin{itemize}
%	\item on considère des points $(E_{\rm ecal}^{0,j}, E_{\rm hcal}^{0,j})$ où nous allons évaluer l'énergie calibrée.
%	\item pour chaque $(E_{\rm ecal}^{0,j}, E_{\rm hcal}^{0,j})$ :
%	\begin{itemize}
%		\item on recherche ses $k$ plus proches voisins dans le plan $(E_{\rm ecal}, E_{\rm hcal}) \rightarrow (E_{\rm ecal}^i, E_{\rm hcal}^i), i \in [|1,...,k|]$
%		\item on trouve la gaussienne correspondante \rightarrow \sigma, \mu$
%		\item $\rightarrow E_{\rm calib}^0 = \mu$
%	\end{itemize}
%	\item on effectue une interpolation pour donner une valeur d'énergie calibrée quelque soit $(E_{\rm ecal}^{0}, E_{\rm hcal}^{0})$
%\end{itemize}
%
\subsubsection{Résultat de la calibration}
- doc git \cite{GitHubKNNGF}
- paramètres : \\
$lim =150, n_{\rm neighbors, Ecal = 0} = 2000, n_{\rm neighbors, Ecal \neq 0} = 250, lim = 150, \sigma  = 5$\\
algorithm = 'auto'\\
kind = 'cubic'\\
energystep_ecal_eq_0 = 1\\
energystep_ecal_neq_0 = 5\\
-> plot surface, courbe de calibration\\
- on calibre un second jeu de données\\
-> plot ecalib/etrue\\
- mise en évidence des non linéarités\\

%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.37\textwidth]{images/pictures/testKNNGF/KNNGaussianFit_plot3D_training.png}
%\includegraphics[width=0.37\textwidth]{images/pictures/testKNNGF/KNNGaussianFit_plot3D_surf.eps}
%\caption{Le nuage de points modélisé (à gauche) par une surface (à droite).}
%\end{center}
%\end{figure}
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGF/KNNGaussianFit_calibration.png}
%\caption{Courbe de calibration pour $E_{\rm ecal} = 0$.}
%\end{center}
%\end{figure}
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGF/KNNGaussianFit_ecalib_over_etrue_functionof_ecal_hcal.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm ecal}$ et $E_{\rm hcal}$.}
%\end{center}
%\end{figure}
%
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/testKNNGF/KNNGaussianFit_ecalib_over_etrue.png}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$.}
%\end{center}
%\end{figure}
%
%
%
%
%\newpage
\section{Comparaison des méthodes}
\label{comparaison}
\subsection{Méthodes des plus proches voisins}
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/comparisons/comparison1.eps}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$.}
%\end{center}
%\end{figure}
%
%
%\section{Meilleure méthode}
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=0.9\textwidth]{images/pictures/comparisons/comparison2.eps}
%\caption{$E_{\rm calib}/E_{\rm true}$ en fonction de $E_{\rm true}$.}
%\end{center}
%\end{figure}
%
%
%
%

\section{Annexes}
\subsection{Fonctions utiles du programme}

\newpage
\bibliographystyle{unsrt}
\bibliography{biblio} % mon fichier de base de données s'appelle biblio.bib

\end{document}

